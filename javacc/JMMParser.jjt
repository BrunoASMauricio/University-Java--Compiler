options {
LOOKAHEAD=1;
}
/*
Example build command
echo "TREE"; jjtree Comp.jjt; echo "CC"; javacc Comp.jj; echo "JAVA"; javac *.java; cat ./testbed/fulltest_1 | java Comp
*/
PARSER_BEGIN(Comp)
import java.util.HashMap;
import java.util.Map;
import java.util.List;
import java.util.ArrayList;

public class Comp
{
    //Map<String, Integer> map = new HashMap<String, Integer>();
    
    static List<ParseException> all_exceptions = new ArrayList<ParseException>();
    static int MAX_EXCEPTIONS = 5;
    static Comp MainProg;
    public static void main(String args[]) throws ParseException {
        System.out.println("Running");
        MainProg = new Comp(System.in);
        try{
            SimpleNode root = MainProg.Program();
            MainProg.eval(root, 0);
            System.out.println();
        }catch(ParseException e){
            System.out.println("UNEXPECTED Parsing Exception");
            smallerExceptionPrint(e);
        }catch(Exception e){
            System.out.println("Non parse exception ocured: ");
            e.printStackTrace();
        }
        if(all_exceptions.size() != 0){
            for(ParseException parse_ex: all_exceptions){
                smallerExceptionPrint(parse_ex);
            }
            //return null;
        }
        //return root;
        //root.dump();
    }
    //https://github.com/javacc/javacc/blob/master/src/main/resources/templates/Token.template
    //https://github.com/javacc/javacc/blob/master/src/main/resources/templates/ParseException.template
    static void smallerExceptionPrint(ParseException e){
        System.out.println("PARSING ERROR");
        //If this object has been created due to a parse error, the token following this token (currentToken) will (therefore) be the first error token.
        System.out.println("Unexpected symbol encountered: "+e.currentToken.next.image+" on line "+e.currentToken.beginLine+", column "+e.currentToken.beginColumn);
        System.out.println("Was expecting one of the following symbols:");

        StringBuffer expected = new StringBuffer();
        expected.append("[ ");

        for(int i = 0; i < e.expectedTokenSequences.length-2; i++){
            expected.append(tokenImage[e.expectedTokenSequences[i][0]]).append(", ");
        }
        if(e.expectedTokenSequences.length > 0){
            expected.append(tokenImage[e.expectedTokenSequences[e.expectedTokenSequences.length-1][0]]).append(" ");
        }
        expected.append(" ]\n");
        
        if(e.expectedTokenSequences.length == 0){
            System.out.println("Nothing, THIS SHOULD BE UNREACHABLE?");
        }else{
            System.out.println(expected+"");
        }
    }
    void eval(SimpleNode node, int depth) {
        //if(node.id == CompTreeConstants.JJTEMPTY) return;
        for(int i = 0; i < depth; i++){
            System.out.print("  ");
        }
        System.out.print(depth+" ");
        switch(node.id){
            case CompTreeConstants.JJTIDENTIFIER:
                System.out.println("[ID: "+node.image+"] ");
                break;
            
            case CompTreeConstants.JJTTYPE:
                System.out.println("[Type: "+node.image+"] ");
                break;
            /*
            case CompTreeConstants.JJTOPERATOR:
                System.out.println("[Operator: "+node.image+"] ");
                break;
            */
            case CompTreeConstants.JJTINTCONST:
                System.out.println("[Int Constant: "+node.int_val+"] ");
                break;
            
            case CompTreeConstants.JJTBOOLCONST:
                System.out.println("[Boolean Constant: "+node.bool_val+"] ");
                break;
            
            default:
                System.out.println(CompTreeConstants.jjtNodeName[node.id]);
        }
        /*
        switch(node.id){
            case CompTreeConstants.JJTMAIN:
                System.out.print("Main Program ");
                break;
            case CompTreeConstants.JJTIDENTIFIER:
                System.out.print("[ID: "+node.Identifier+"] ");
                break;
            case CompTreeConstants.JJTTYPE:
                System.out.print("[Type] ");
                break;
            case CompTreeConstants.JJTNEW:
                System.out.print("[new] ");
                break;
            case CompTreeConstants.JJTARGUMENTS:
                System.out.print("[arguments] ");
                break;

            case CompTreeConstants.JJTVARDECLARATION:
                System.out.print("[VarDeclaration] ");
                break;
            case CompTreeConstants.JJTIMPORTDECLARATION:
                System.out.print("ImportDeclaration");
                break;
            case CompTreeConstants.JJTCLASSDECLARATION:
                System.out.print("[ClassDeclaration] ");
                break;
            case CompTreeConstants.JJTMETHODDECLARATION:
                System.out.print("[MethodDeclaration] ");
                break;
                
            case CompTreeConstants.JJTSTATEMENT:
                System.out.print("[statement] ");
                break;
            case CompTreeConstants.JJTEXPR:
                System.out.print("[RHS expression] ");
                break;
                
            case CompTreeConstants.JJTWHILE:
                System.out.print("[while] ");
                break;
            case CompTreeConstants.JJTWHILECOND:
                System.out.print("[while cond] ");
                break;
            case CompTreeConstants.JJTIF:
                System.out.print("[if] ");
                break;
            case CompTreeConstants.JJTIFCOND:
                System.out.print("[if cond] ");
                break;
            case CompTreeConstants.JJTELSEBODY:
                System.out.print("[else] ");
                break;
            case CompTreeConstants.JJTRETURN:
                System.out.print("[returns] ");
                break;

            case CompTreeConstants.JJTLESSTHAN:
                System.out.print("[<] ");
                break;
            case CompTreeConstants.JJTADD:
                System.out.print("[+] ");
                break;
            case CompTreeConstants.JJTSUB:
                System.out.print("[-] ");
                break;
            case CompTreeConstants.JJTMUL:
                System.out.print("[*] ");
                break;
            case CompTreeConstants.JJTDIV:
                System.out.print("[/] ");
                break;

            case CompTreeConstants.JJTATTR:
                System.out.print("[attribution] ");
                break;
            case CompTreeConstants.JJTARATTR:
                System.out.print("[array attribution] ");
                break;
                
            case CompTreeConstants.JJTINTCONST:
                System.out.print("[int constant: "+String.valueOf(node.val)+"] ");
                break;
            case CompTreeConstants.JJTBOOLCONST:
                System.out.print("[boolean constant] ");
                break;
            case CompTreeConstants.JJTTHIS:
                System.out.print("[this] ");
                break;
            default:
                System.out.print("["+String.valueOf(node.id)+"] ");
                break;
        }
        if(node.type != null) System.out.print("Node type: "+node.type+" ");
        
        if(node.import_list != null && node.import_list.size() != 0){
            System.out.print("import ");
            for(String import_path : node.import_list){
                System.out.print(" "+import_path);
            }
            System.out.print(" ");
        }
        */
        SimpleNode lhs;
        SimpleNode rhs;
        int n_children = node.jjtGetNumChildren();
        for(int i = 0; i < n_children; i++){
            lhs = (SimpleNode) node.jjtGetChild(i);
            eval(lhs, depth+1);
        }
    }
    //Addapted from https://javacc.github.io/javacc/tutorials/error-handling.html
    void error_skipto(int kind, ParseException e) {
        if(all_exceptions.size() == MAX_EXCEPTIONS){
            //throw new Exception("Maximum ammount of exceptions caught.");
        }
        all_exceptions.add(e);
        Token t;
        do{
            t = getNextToken();
        }while (t.kind != kind);
    }
}
PARSER_END(Comp)
SKIP :
{
//Eventually when we handle string parsing, remove these from here
" "
|"\r"
|"\t"
|"\n"
//Ignore comments

|< "/*" (~["*"])* "*" ( ~["*","/"] (~["*"])* "*" | "*" )* "/" >
|< "//" (~["\n"])+ ("\n" | "\r" | "\r\n") >

}
/*
GENERAL RULE, TOKENS THAT INCLUDE EACHOTHER (in is included by int) MUST ALWAYS APPEAR
SHORTEST TOKEN FIRST
i.e.
>in
>int
and NOT
>int
>i

TODO
Accept hex/bin number notation
*/
TOKEN:
{

< INTEGER: (["0"-"9"])+ >
|< LF: "\n" | "\r" | "\r\n" >

|< SC: ";" >
|< NEW: "new" >
|< OP: "(" >
|< CP: ")" >
|< OSB: "[" >
|< CSB: "]" >
|< OB: "{" >
|< CB: "}" >

|< NOT: "!" >
|< ADD: "+" >
|< SUB: "-" >
|< MUL: "*" >
|< DIV: "/" >
|< LESSTHAN: "<" >
|< AND: "&&" >
|< EQ: "=" >
|< SELECTOR: "." >
|< SEPARATOR: "," >

|< THIS: "this" >
|< IF: "if" >
|< ELSE: "else" >
|< WHILE: "while" >
|< RETURN: "return" >

|< BOOL: "true" | "false" >
|< BOOLEAN: "boolean" >
|< INT: "int" >

|< STRING: "String" >
|< LENGTH: "length" >
|< IMPORT: "import" >
|< EXTENDS: "extends" >
|< PUBLIC: "public" >
|< VOID: "void" >
|< MAIN: "main" >
|< STATIC: "static" >
|< CLASS: "class" >
|
// ID MUST ALWAYS BE THE LAST TOKEN BECAUSE OTHERWISE IT WILL BE MATCH EVERY STRING
< ID: ["a"-"z","A"-"Z","_","$"] ( ["a"-"z","A"-"Z","$","_","0"-"9"] )* >
}

SimpleNode Program() #START: {}
{
    (
        ( ImportDeclaration() )* ClassDeclaration() <EOF>
    ) {return jjtThis;}
}

void ImportDeclaration(): {}
{
    <IMPORT> ( <STATIC> )? Identifier() ( <SELECTOR> Identifier() )*
    ( <OP> ( (Type() ( <SEPARATOR> Type() )*) | <VOID> )? <CP> )?
    ( <VOID> | Type() #RETURN  )? <SC>
}

void VarDeclaration(): {}
{
    Type() Identifier() <SC>
}

void ClassHead(): {}
{
    Identifier() ( <EXTENDS> Identifier() )?
}

void ClassDeclaration(): {}
{
    <CLASS> ClassHead() <OB>
        ( VarDeclaration() )*
        ( MethodDeclaration() )*
        
    <CB>
}

void MethodHead(): {}
{
    //Return is unnecessary here because the first token MUST be a Type, and is always the return type
    //First token is return type, Second token is method name
    //From then on, Type Identifier pairs are the arguments 
    Type() /* #RETURN */ Identifier() <OP> ( (Type() Identifier() ( <SEPARATOR> Type() Identifier() )* ) | <VOID> )?
}

void MainMethod(): {}
{
    <STATIC> <VOID> <MAIN> <OP>
        <STRING> <OSB> <CSB> Identifier()
    <CP> <OB>
    ( LOOKAHEAD(2) VarDeclaration() )*
    ( Statement() )*
    <CB>
}

void NormalMethod(): {}
{
    MethodHead()
    <CP> <OB>
        ( LOOKAHEAD(2) VarDeclaration() )*
        ( Statement() )*
        ( <RETURN> Expression() <SC> )?
    <CB>
}

void MethodDeclaration()#void: {}
{
    <PUBLIC>
        (
        NormalMethod()
        |
        MainMethod()
        )
}

void BoolConst(): {Token t;}
{
    t=<BOOL>{
        jjtThis.bool_val = Boolean.parseBoolean(t.image);
    }
}
void IntConst(): {Token t;}
{
    t=<INTEGER>{
        jjtThis.int_val = Integer.parseInt(t.image);
    }
}

void And()#void:{}
{
    Lessthan() And1()
}

void And1()#void: {}
{
    "&&" Lessthan() #AND(2) And1()
    |
    Empty()
}

void Lessthan()#void: {}
{
    Add() Lessthan1()
}

void Lessthan1()#void: {}
{
    "<" Add() #LESSTHAN(2) Lessthan1()
    |
    Empty()
}

void Add()#void: {}
{
    Mul() Add1()
}

void Add1()#void: {}
{
    ("+"| "-") Mul() #ADD(2) Add1()
    |
    Empty()
}

void Mul()#void: {}
{
    Node() Mul1()
}

void Mul1()#void: {}
{
    ("*"| "/") Node() #MUL(2) Mul1()
    |
    Empty()
}

void SelectorArguments(): {}
{
    Expression() ( <SEPARATOR> Expression() )*
}

void Selector_1()#void: {}
{
    Identifier() ( <OP> ( SelectorArguments() )? <CP> )?
    |
    <LENGTH>
}

void Selector(): {}
{
    <SELECTOR> Selector_1()
    |
    <OSB> Expression() <CSB>
}

void This()#THIS: {}
{
    <THIS> ( Selector() )*
}

void New(): {}
{
    <INT> <OSB> Expression() <CSB>
    |
    Identifier() <OP> <CP>
}

void Negate(): {}
{
    <NOT> Expression()
}

void Node()#void: {}
{
    IntConst()
    |
    BoolConst()
    |
    Identifier() ( Selector() )*
    |
    <OP> And() <CP>
    |
    This()
    |
    <NEW> New() ( Selector() )*
    |
    Negate()

}

void Expression()#void: {}
{
    And()
}

/*
void Expression()#void: {}
{
    Terminal() Expression_1()
    |
    <THIS> Expression_1()
    |
    <NEW> New()
    |
    Negate() Expression_1()
    |
    <OP> Expression() <CP> Expression_1()
}

void Expression_1()#void: {}
{
    <OSB> Expression() <CSB> Expression_1()
    |
    <SELECTOR> Selector() Expression_1()
    |
    Empty()
}
*/

//Access here is unnecessary because the First Token is always the target ID
//More tokens imply an expression that can then be computed
void Access()#void /* #Access */: {}
{
    <OSB> Expression() <CSB>
}

void Target()#Target: {}
{
    Identifier() ( Access() )?
}
void Attribution()#Attribution: {}
{
    Target() <EQ> Expression() <SC>
}

void Statement()#void: {}
{
    IfStructure()
    |
    WhileStructure()
    |
    <OB> ( Statement() )* <CB>
    |
    LOOKAHEAD(2)
    Attribution()
    |
    Expression() <SC>
}

void IfHead(): {}
{
    Expression()
}

void IfStructure(): {}
{
    <IF> <OP> IfHead()  <CP> Statement() ElseStructure()
}

void ElseStructure(): {}
{
    <ELSE> Statement()
}

//Needed because expressions inside the while body would be confused with those inside the head
void WhileHead(): {}
{
    Expression()
}

void WhileStructure(): {}
{
    <WHILE>
    try{
        <OP> WhileHead() <CP> Statement()
    }catch (ParseException e) {
        System.out.println("COULD NOT PARSE WHILE");
        Comp.MainProg.error_skipto(CB, e);
    }
}

void Type(): {Token t;}
{
    <INT> (
        <OSB> <CSB>{
            jjtThis.image = "int[]";
        }
        |
        Empty(){
            jjtThis.image = "int";
        }
        )
    |
    <STRING> (
        <OSB> <CSB>{
            jjtThis.image = "String[]";
        }
        |
        Empty(){
            jjtThis.image = "String";
        }
        )
    |
    <BOOLEAN>{
        jjtThis.image = "boolean";
    }
    |
    t=<ID>{
        jjtThis.image = t.image+"";
    }
}

void Empty()#void: {}
{
    {}
}

void Identifier(): {Token t;}
{
    t=<ID>{
        jjtThis.image = t.image+"";
    }
}

