options {
LOOKAHEAD=1;
}
PARSER_BEGIN(JMMParser)

import java.io.InputStream;
//import java.util.HashMap;
//import java.util.Map;
import java.util.List;
import java.util.ArrayList;

public class JMMParser{
    
    static List<ParseException> all_exceptions = new ArrayList<ParseException>();
    static int MAX_EXCEPTIONS = 5;
    
    static SimpleNode parse(InputStream input_stream){
        SimpleNode root = null;
        all_exceptions.clear();
        JMMParser MainProg = new JMMParser(input_stream);

        System.out.println("Parser starting");


        try{
            root = MainProg.Program();
            //MainProg.eval(root, 0);
            System.out.println();
        }catch(ParseException e){
            System.out.println("UNEXPECTED Parsing Exception");
            printParsingException(e);
        }catch(Exception e){
            System.out.println("Non parse exception ocured: ");
            System.out.println(e);
        }
        if(all_exceptions.size() != 0){
            for(ParseException parse_ex: all_exceptions){
                printParsingException(parse_ex);
            }
            return null;
        }
        return root;
    }

    //https://github.com/javacc/javacc/blob/master/src/main/resources/templates/Token.template
    //https://github.com/javacc/javacc/blob/master/src/main/resources/templates/ParseException.template
    static void printParsingException(ParseException e){
        System.out.println("PARSING ERROR");
        //If this object has been created due to a parse error, the token following this token (currentToken) will (therefore) be the first error token.
        System.out.println("Unexpected symbol encountered: \"+e.currentToken.next.image+\" on line "+e.currentToken.beginLine+", column "+e.currentToken.beginColumn);
        System.out.println("Was expecting one of the following symbols:");

        StringBuffer expected = new StringBuffer();
        expected.append("[ ");

        for(int i = 0; i < e.expectedTokenSequences.length-2; i++){
            expected.append(tokenImage[e.expectedTokenSequences[i][0]]).append(", ");
        }
        if(e.expectedTokenSequences.length > 0){
            expected.append(tokenImage[e.expectedTokenSequences[e.expectedTokenSequences.length-1][0]]).append(" ");
        }
        expected.append(" ]");
        
        if(e.expectedTokenSequences.length == 0){
            System.out.println("Nothing, THIS SHOULD BE UNREACHABLE?");
        }else{
            System.out.println(expected+"");
        }
    }
    
    int eval(SimpleNode node, int depth) {
        /*
        if(node.id == CompTreeConstants.JJTEMPTY) return;
        System.out.println();
        for(int i = 0; i < depth; i++){
            System.out.print("  ");
        }
        System.out.print(depth+" ");
        switch(node.id){
            case CompTreeConstants.JJTMAIN:
                System.out.print("Main Program ");
                break;
            case CompTreeConstants.JJTIDENTIFIER:
                System.out.print("[ID] ");
                break;
            case CompTreeConstants.JJTTYPE:
                System.out.print("[Type] ");
                break;
            case CompTreeConstants.JJTVARDECLARATION:
                System.out.print("[VarDeclaration] ");
                break;
            case CompTreeConstants.JJTIMPORTDECLARATION:
                System.out.print("ImportDeclaration");
                break;
            case CompTreeConstants.JJTCLASSDECLARATION:
                System.out.print("[ClassDeclaration] ");
                break;
            case CompTreeConstants.JJTMETHODDECLARATION:
                System.out.print("[MethodDeclaration] ");
                break;
            case CompTreeConstants.JJTWHILE:
                System.out.print("[while] ");
                break;
            case CompTreeConstants.JJTIF:
                System.out.print("[if] ");
                break;
            case CompTreeConstants.JJTIFCOND:
                System.out.print("[if cond] ");
                break;
            case CompTreeConstants.JJTIFBODY:
                System.out.print("[if body] ");
                break;
            case CompTreeConstants.JJTELSE:
                System.out.print("[else] ");
                break;
            case CompTreeConstants.JJTRETURN:
                System.out.print("[returns] ");
                break;
            default:
                System.out.print("["+String.valueOf(node.id)+"] ");
                break;
        }
        if(node.type != null) System.out.print("Node type: "+node.type+" ");
        
        if(node.import_list != null && node.import_list.size() != 0){
            System.out.print("import ");
            for(String import_path : node.import_list){
                System.out.print(" "+import_path);
            }
            System.out.print(" ");
        }
        SimpleNode lhs;
        SimpleNode rhs;
        int n_children = node.jjtGetNumChildren();
        switch(n_children){
            case 0:
                //System.out.print("LEAF");
                return;
            case 1:
                lhs = (SimpleNode) node.jjtGetChild(0); //left child
                //System.out.print("Just going left");
                if(lhs != null) eval(lhs, depth+1);
                return;
            case 2:
                lhs = (SimpleNode) node.jjtGetChild(0); //left child
                rhs = (SimpleNode) node.jjtGetChild(1); // right child
                //System.out.print("2 children");

                if(lhs != null) eval(lhs, depth+1);

                if(rhs != null) eval(rhs, depth+1);
                return;
            default:
                for(int i = 0; i < n_children; i++){
                    lhs = (SimpleNode) node.jjtGetChild(i);
                    eval(lhs, depth+1);
                }
                break;
        }
        */
        return 0;
    }
}
PARSER_END(JMMParser)
SKIP :
{
//Eventually when we handle string parsing, remove these from here
" "
|"\r"
|"\t"
|"\n"
//Ignore comments

|< "/*" (~["*"])* "*" ( ~["*","/"] (~["*"])* "*" | "*" )* "/" >
|< "//" (~["\n"])+ ("\n" | "\r" | "\r\n") >

}
/*
GENERAL RULE, TOKENS THAT INCLUDE EACHOTHER (in is included by int) MUST ALWAYS APPEAR
SHORTEST TOKEN FIRST
i.e.
>in
>int
and NOT
>int
>i

TODO
Accept hex/bin number notation
*/
TOKEN:
{

< INTEGER: (["0"-"9"])+ >
|< LF: "\n" | "\r" | "\r\n" >

|< SC: ";" >
|< NEW: "new" >
|< OP: "(" >
|< CP: ")" >
|< OSB: "[" >
|< CSB: "]" >
|< OB: "{" >
|< CB: "}" >

|< NOT: "!" >
|< ADD: "+" >
|< SUB: "-" >
|< MUL: "*" >
|< DIV: "/" >
|< LESSTHAN: "<" >
|< BOOLAND: "&&" >
|< EQ: "=" >
|< SELECTOR: "." >
|< SEPARATOR: "," >

|< THIS: "this" >
|< IF: "if" >
|< ELSE: "else" >
|< WHILE: "while" >
|< RETURN: "return" >

|< BOOL: "true" | "false" >
|< BOOLEAN: "boolean" >
|< INT: "int" >

|< STRING: "String" >
|< LENGTH: "length" >
|< IMPORT: "import" >
|< EXTENDS: "extends" >
|< PUBLIC: "public" >
|< VOID: "void" >
|< MAIN: "main" >
|< STATIC: "static" >
|< CLASS: "class" >
|
// ID MUST ALWAYS BE THE LAST TOKEN BECAUSE OTHERWISE IT WILL BE MATCH EVERY STRING
< ID: ["a"-"z","A"-"Z","_","$"] ( ["a"-"z","A"-"Z","$","_","0"-"9"] )* >
}

SimpleNode Program() #MAIN: {}
{
    (
        ( ImportDeclaration() )* ClassDeclaration() <EOF>
    ) {return jjtThis;}
}

void Empty() : {}
{
     {}
}

void Identifier(): {Token t;}
{
    t=<ID>{
        jjtThis.Identifier = t.image+"";
        System.out.println(t.image+",");
    }
}

void Type() #Type : {Token t;}
{
    LOOKAHEAD(2)
    t=<INT>{
        jjtThis.type = "int[]";
    } <OSB> <CSB>
    |
    t=<INT>{
        jjtThis.type = "int";
    }
    |
    LOOKAHEAD(2)
    t=<STRING>{
        jjtThis.type = "String[]";
    } <OSB> <CSB>
    |
    t=<STRING>{
        jjtThis.type = "String";
    }
    |
    t=<BOOLEAN>{
        jjtThis.type = "boolean";
    }
    |
    Identifier()
}

void VarDeclaration(): {}
{
    Type() Identifier() <SC>
}


void ImportDeclaration(): {Token import_section;}
{
    //import_section hops on all path sections of the import
    <IMPORT> (<STATIC>)? import_section=<ID>{
        jjtThis.import_list.add(import_section.image+"");
    }
    
    (
        <SELECTOR> import_section=<ID>{
            jjtThis.import_list.add(import_section.image+"");
        }
    )*
    (<OP> ( (Type() (<SEPARATOR> Type() )*) | <VOID> )? <CP>)? ( <VOID> | Type() #RETURN)? <SC>
}

void ClassDeclaration(): {Token t;}
{
    <CLASS> t=<ID>{
        jjtThis.class_name=t.image+"";
    } ( <EXTENDS> t=<ID>{
        jjtThis.class_extends=t.image+"";
    } )? <OB>
        ( LOOKAHEAD(2) VarDeclaration() )*
        ( MethodDeclaration() )*
    <CB>
}

void MethodDeclaration():{}
{
    LOOKAHEAD(2)
    <PUBLIC> Type() Identifier() <OP> ( (Type() Identifier() ( <SEPARATOR> Type() Identifier() )* ) | <VOID> )? <CP> <OB>
        
        ( LOOKAHEAD(2) VarDeclaration() )*
        ( Statement() )*
        ( "return" Expression() <SC> )?
    <CB>
    |
    <PUBLIC> <STATIC> <VOID> <MAIN> <OP>
        <STRING> <OSB> <CSB> Identifier()
    <CP> <OB>
        ( LOOKAHEAD(2) VarDeclaration() )*
        ( Statement() )*
    <CB>

}

void Expression() #void: {}
{
    IntegerConstant() Expression_1()
    |
    BooleanConstant() Expression_1()
    |
    <THIS> #THIS Expression_1()
    |
    <NEW> New()
    |
    <NOT> Expression() Expression_1()               //! expr()
    |
    <OP> Expression() <CP> Expression_1()           // ( expr() )
    |
    Identifier()    Expression_1()
}
/*
Cant access jjtThis if #void is present, so need to break Expression into pieces
*/
void IntegerConstant() #INTCONST: {Token t;}
{
    t = <INTEGER>{
        jjtThis.val = Integer.parseInt(t.image);
    }
}
void BooleanConstant() #BOOLCONST: {Token t;}
{
    t = <BOOL>{
        //jjtThis.bool_val = Boolean.parseBoolean(t.image);
    }
}
void New() #NEW: {Token t;}
{
    <INT> <OSB> Expression() <CSB> Expression_1()   //new type[]
    |
    Identifier() <OP> <CP> Expression_1()           //new var ()
}

/*
Second part of Expression (to avoid left-recursivity)
*/
void Expression_1() #void: {}
{
    ( <BOOLAND> #AND | <LESSTHAN> #LESSTHAN | <ADD> #ADD | <SUB> #SUB | <MUL> #MUL | <DIV> #DIV) Expression() Expression_1()
    |
    <OSB> Expression() <CSB> Expression_1()
    |
    LOOKAHEAD(2)
    <SELECTOR> <LENGTH> Expression_1()
    |
    <SELECTOR> Identifier() <OP> [ Expression() (<SEPARATOR> Expression())* ] <CP> Expression_1()
    |
    Empty()
}


void Statement() : {System.out.println("Cool\n\n");}
{
    <OB> (Statement())* <CB>
    |
    <IF> ifcond()
    |
    <WHILE> whileLoop()
    |
    LOOKAHEAD(2)
    Identifier() <EQ> #ATTR Expression() <SC>
    |
    LOOKAHEAD(2)
    Identifier() <OSB> Expression()  <CSB> <EQ> #ATTR Expression() <SC>
    |
    //TO REMOVE THIS ONE AND SWAP WITH A LOOKAHEAD(2 or 1)
    Expression() <SC>
}

//          IF HANDLING
void ifcond() #void/* #IF */: {}
{
    <OP> Expression() #IFCOND <CP> Statement()/* #IFBODY */ <ELSE> elsecond()
}
//          ELSE HANDLING
void elsecond() /* #ELSE */ : {}
{
    Statement()
} 
//          WHILE HANDLING
void whileLoop() #WHILE:{}
{
    try {
    (
        <OP> Expression() #WHILECOND <CP> Statement()
    )
    }catch (ParseException e) {
        System.out.println("Could not parse while");
        System.out.println(e.toString());
        error_skipto(CB, "no Expression found");
    }
}


JAVACODE
//Addapted from https://javacc.github.io/javacc/tutorials/error-handling.html
void error_skipto(int kind, String a) {
    ParseException e = generateParseException();
    System.out.println(e.toString());
    Token t;
    do {
        t = getNextToken();
    }
    while (t.kind != kind);
}