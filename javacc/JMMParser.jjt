options {
LOOKAHEAD=1;
}
PARSER_BEGIN(JMMParser)

import java.io.InputStream;
//import java.util.HashMap;
//import java.util.Map;
import java.util.List;
import java.util.ArrayList;

public class JMMParser{
    
    static List<ParseException> all_exceptions = new ArrayList<ParseException>();
    static int MAX_EXCEPTIONS = 5;
    
    static SimpleNode parse(InputStream input_stream){
        SimpleNode root = null;
        all_exceptions.clear();
        JMMParser MainProg = new JMMParser(input_stream);

        System.out.println("Parser starting");

        try{
            root = MainProg.Program();
            
        }catch(ParseException e){
            System.out.println("UNEXPECTED Parsing Exception");
            printParsingException(e);
        }catch(Exception e){
            System.out.println("Non parse exception ocured: ");
            System.out.println(e);
        }
        if(all_exceptions.size() != 0){
            for(ParseException parse_ex: all_exceptions){
                printParsingException(parse_ex);
            }
            return null;
        }
        return root;
    }

    //https://github.com/javacc/javacc/blob/master/src/main/resources/templates/Token.template
    //https://github.com/javacc/javacc/blob/master/src/main/resources/templates/ParseException.template
    static void printParsingException(ParseException e){
        System.out.println("PARSING ERROR");
        //If this object has been created due to a parse error, the token following this token (currentToken) will (therefore) be the first error token.
        System.out.println("Unexpected symbol encountered: \"+e.currentToken.next.image+\" on line "+e.currentToken.beginLine+", column "+e.currentToken.beginColumn);
        System.out.println("Was expecting one of the following symbols:");

        StringBuffer expected = new StringBuffer();
        expected.append("[ ");

        for(int i = 0; i < e.expectedTokenSequences.length-2; i++){
            expected.append(tokenImage[e.expectedTokenSequences[i][0]]).append(", ");
        }
        if(e.expectedTokenSequences.length > 0){
            expected.append(tokenImage[e.expectedTokenSequences[e.expectedTokenSequences.length-1][0]]).append(" ");
        }
        expected.append(" ]\n");
        
        if(e.expectedTokenSequences.length == 0){
            System.out.println("Nothing, THIS SHOULD BE UNREACHABLE?");
        }else{
            System.out.println(expected+"");
        }
    }
    
    static int eval(SimpleNode node, int depth) {
        SimpleNode lhs;
        SimpleNode rhs;
        int n_children;

        for(int i = 0; i < depth; i++){
            System.out.print("  ");
        }
        
        System.out.print(depth+" ");
        
        switch(node.id){
            case JMMParserTreeConstants.JJTIDENTIFIER:
                System.out.println("[ID: "+node.image+"] ");
                break;
            
            case JMMParserTreeConstants.JJTTYPE:
                System.out.println("[Type: "+node.image+"] ");
                break;
            
            case JMMParserTreeConstants.JJTOPERATOR:
                System.out.println("[Operator: "+node.image+"] ");
                break;
            
            case JMMParserTreeConstants.JJTINTCONST:
                System.out.println("[Int Constant: "+node.int_val+"] ");
                break;
            
            case JMMParserTreeConstants.JJTBOOLCONST:
                System.out.println("[Boolean Constant: "+node.bool_val+"] ");
                break;
            
            default:
                System.out.println(JMMParserTreeConstants.jjtNodeName[node.id]);
        }

        n_children = node.jjtGetNumChildren();
        
        for(int i = 0; i < n_children; i++){
            lhs = (SimpleNode) node.jjtGetChild(i);
            eval(lhs, depth+1);
        }
        
        return 0;
    }
}

PARSER_END(JMMParser)
SKIP :
{
//Eventually when we handle string parsing, remove these from here
" "
|"\r"
|"\t"
|"\n"
//Ignore comments

|< "/*" (~["*"])* "*" ( ~["*","/"] (~["*"])* "*" | "*" )* "/" >
|< "//" (~["\n"])+ ("\n" | "\r" | "\r\n") >

}
/*
GENERAL RULE, TOKENS THAT INCLUDE EACHOTHER (in is included by int) MUST ALWAYS APPEAR
SHORTEST TOKEN FIRST
i.e.
>in
>int
and NOT
>int
>i

TODO
Accept hex/bin number notation
*/
TOKEN:
{

< INTEGER: (["0"-"9"])+ >
|< LF: "\n" | "\r" | "\r\n" >

|< SC: ";" >
|< NEW: "new" >
|< OP: "(" >
|< CP: ")" >
|< OSB: "[" >
|< CSB: "]" >
|< OB: "{" >
|< CB: "}" >

|< NOT: "!" >
|< ADD: "+" >
|< SUB: "-" >
|< MUL: "*" >
|< DIV: "/" >
|< LESSTHAN: "<" >
|< BOOLAND: "&&" >
|< EQ: "=" >
|< SELECTOR: "." >
|< SEPARATOR: "," >

|< THIS: "this" >
|< IF: "if" >
|< ELSE: "else" >
|< WHILE: "while" >
|< RETURN: "return" >

|< BOOL: "true" | "false" >
|< BOOLEAN: "boolean" >
|< INT: "int" >

|< STRING: "String" >
|< LENGTH: "length" >
|< IMPORT: "import" >
|< EXTENDS: "extends" >
|< PUBLIC: "public" >
|< VOID: "void" >
|< MAIN: "main" >
|< STATIC: "static" >
|< CLASS: "class" >
|
// ID MUST ALWAYS BE THE LAST TOKEN BECAUSE OTHERWISE IT WILL BE MATCH EVERY STRING
< ID: ["a"-"z","A"-"Z","_","$"] ( ["a"-"z","A"-"Z","$","_","0"-"9"] )* >
}

SimpleNode Program() #START: {}
{
    (
        ( ImportDeclaration() )* ClassDeclaration() <EOF>
    ) {return jjtThis;}
}

void ImportDeclaration(): {}
{
    <IMPORT> ( <STATIC> )? Identifier() ( <SELECTOR> Identifier() )*
    ( <OP> ( (Type() ( <SEPARATOR> Type() )*) | <VOID> )? <CP> )?
    ( <VOID> | Type() #RETURN  )? <SC>
}

void VarDeclaration(): {}
{
    Type() Identifier() <SC>
}

void ClassHead(): {}
{
    Identifier() ( <EXTENDS> Identifier() )?
}

void ClassDeclaration(): {}
{
    <CLASS> ClassHead() <OB>
        ( VarDeclaration() )*
        ( MethodDeclaration() )*
        
    <CB>
}

void MethodHead(): {}
{
    //Return is unnecessary here because the first token MUST be a Type, and is always the return type
    //First token is return type, Second token is method name
    //From then on, Type Identifier pairs are the arguments 
    Type() /* #RETURN */ Identifier() <OP> ( (Type() Identifier() ( <SEPARATOR> Type() Identifier() )* ) | <VOID> )?
}

void MainMethod(): {}
{
    <STATIC> <VOID> <MAIN> <OP>
        <STRING> <OSB> <CSB> Identifier()
    <CP> <OB>
    ( LOOKAHEAD(2) VarDeclaration() )*
    ( Statement() )*
    <CB>
}

void NormalMethod(): {}
{
    MethodHead()
    <CP> <OB>
        ( LOOKAHEAD(2) VarDeclaration() )*
        ( Statement() )*
        ( <RETURN> Expression() <SC> )?
    <CB>
}

void MethodDeclaration()#void: {}
{
    <PUBLIC>
        (
        NormalMethod()
        |
        MainMethod()
        )
}

void New(): {}
{
    <INT> <OSB> Expression() <CSB> Expression_1()
    |
    Identifier() <OP> <CP> Expression_1()
}

void Negate(): {}
{
    <NOT> Expression()
}
void BoolConst(): {Token t;}
{
    t=<BOOL>{
        jjtThis.bool_val = Boolean.parseBoolean(t.image);
    }
}
void IntConst(): {Token t;}
{
    t=<INTEGER>{
        jjtThis.int_val = Integer.parseInt(t.image);
    }
}
void Expression()#void: {}
{
    IntConst() Expression_1()
    |
    BoolConst() Expression_1()
    |
    <THIS> Expression_1()
    |
    <NEW> New()
    |
    Negate() Expression_1()
    |
    <OP> Expression() <CP> Expression_1()
    |
    Identifier() Expression_1()
}

void Operator(): {Token t;}
{
    ( t="&&" | t="<" | t="+" | t="-" | t="*" | t="/"){
        jjtThis.image = t.image;
    }
}
void Operation()#void: {}
{
    Operator() Expression()
}

void Expression_1()#void: {}
{
    Operation() Expression_1()
    |
    <OSB> Expression() <CSB> Expression_1()
    |
    <SELECTOR> Selector() Expression_1()
    |
    Empty()
}

void SelectorArguments(): {}
{
    [ Expression() ( <SEPARATOR> Expression() )* ]
}

void Selector(): {}
{
    <LENGTH> #LENGTH
    |
    Identifier() <OP> SelectorArguments() <CP>
}

//Access here is unnecessary because the First Token is always the target ID
//More tokens imply an expression that can then be computed
void Access()#void /* #Access */: {}
{
    <OSB> Expression() <CSB>
}

void Target()#Target: {}
{
    Identifier() ( Access() )?
}
void Attribution()#Attribution: {}
{
    Target() <EQ> Expression() <SC>
}

void Statement()#void: {}
{
    IfStructure()
    |
    WhileStructure()
    |
    <OB> ( Statement() )* <CB>
    |
    LOOKAHEAD(2)
    Attribution()
    |
    Expression() <SC>
}

void IfHead(): {}
{
    Expression()
}

void IfStructure(): {}
{
    <IF> <OP> IfHead()  <CP> Statement() ElseStructure()
}

void ElseStructure(): {}
{
    <ELSE> Statement()
}

//Needed because expressions inside the while body would be confused with those inside the head
void WhileHead(): {}
{
    Expression()
}

void WhileStructure(): {}
{
    <WHILE>
    try{
        <OP> WhileHead() <CP> Statement()
    }catch (ParseException e) {
        System.out.println("COULD NOT PARSE WHILE");
        error_skipto(CB, e);
    }
}

void Type(): {Token t;}
{
    <INT> (
        <OSB> <CSB>{
            jjtThis.image = "int[]";
        }
        |
        Empty(){
            jjtThis.image = "int";
        }
        )
    |
    <STRING> (
        <OSB> <CSB>{
            jjtThis.image = "String[]";
        }
        |
        Empty(){
            jjtThis.image = "String";
        }
        )
    |
    <BOOLEAN>{
        jjtThis.image = "boolean";
    }
    |
    t=<ID>{
        jjtThis.image = t.image+"";
    }
}

void Empty()#void: {}
{
    {}
}

void Identifier(): {Token t;}
{
    t=<ID>{
        jjtThis.image = t.image+"";
    }
}
JAVACODE
//Addapted from https://javacc.github.io/javacc/tutorials/error-handling.html
void error_skipto(int kind, ParseException e) throws Exception{
    if(all_exceptions.size() == MAX_EXCEPTIONS){
        throw new Exception("Maximum ammount of exceptions caught.");
    }
    all_exceptions.add(e);
    Token t;
    do{
        t = getNextToken();
    }while(t.kind != kind);
}