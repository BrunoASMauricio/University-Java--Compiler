/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. JMMParser.jj */
/*@egen*/options {
LOOKAHEAD=1;
                                 
                  
}
/*
Example build command
echo "TREE"; jjtree Comp.jjt; echo "CC"; javacc Comp.jj; echo "JAVA"; javac *.java; cat ./testbed/fulltest_1 | java Comp
*/
PARSER_BEGIN(JMMParser)

import java.util.List;
import java.util.ArrayList;
import java.io.InputStream;

public class JMMParser/*@bgen(jjtree)*/implements JMMParserTreeConstants/*@egen*/{/*@bgen(jjtree)*/
  protected static JJTJMMParserState jjtree = new JJTJMMParserState();

/*@egen*/
    
    static List<ParseException> all_exceptions = new ArrayList<ParseException>();
    static int MAX_EXCEPTIONS = 5;
    
    static SimpleNode parse(InputStream input_stream) throws Exception{
        SimpleNode root = null;
        all_exceptions.clear();
        JMMParser MainProg = new JMMParser(input_stream);

        System.out.println("Parser starting");

        try{
            root = MainProg.Program();
            
        }catch(ParseException e){
            System.out.println("UNEXPECTED Parsing Exception");
            printParsingException(e);
        }catch(Exception e){
            System.out.println("Non parse exception ocured: ");
            System.out.println(e);
            throw new Exception("Parser failure");
        }
        if(all_exceptions.size() != 0){
            for(ParseException parse_ex: all_exceptions){
                printParsingException(parse_ex);
            }
            throw new Exception("Parser failure");
            //return null;
        }
        return root;
    }

    //https://github.com/javacc/javacc/blob/master/src/main/resources/templates/Token.template
    //https://github.com/javacc/javacc/blob/master/src/main/resources/templates/ParseException.template
    static void printParsingException(ParseException e){
        System.out.println("PARSING ERROR");
        //If this object has been created due to a parse error, the token following this token (currentToken) will (therefore) be the first error token.
        System.out.println("Unexpected symbol encountered: "+e.currentToken.next.image+" on line "+e.currentToken.beginLine+", column "+e.currentToken.beginColumn);
        System.out.println("Was expecting one of the following symbols:");

        StringBuffer expected = new StringBuffer();
        expected.append("[ ");

        for(int i = 0; i < e.expectedTokenSequences.length-2; i++){
            expected.append(tokenImage[e.expectedTokenSequences[i][0]]).append(", ");
        }
        if(e.expectedTokenSequences.length > 0){
            expected.append(tokenImage[e.expectedTokenSequences[e.expectedTokenSequences.length-1][0]]).append(" ");
        }
        expected.append(" ]\n");
        
        if(e.expectedTokenSequences.length == 0){
            System.out.println("Nothing, THIS SHOULD BE UNREACHABLE?");
        }else{
            System.out.println(expected+"");
        }
    }
    
    static int eval(SimpleNode node, int depth) {
        SimpleNode lhs;
        SimpleNode rhs;
        int n_children;

        for(int i = 0; i < depth; i++){
            System.out.print("  ");
        }
        
        System.out.print(depth+" ");
        
        switch(node.id){
            case JMMParserTreeConstants.JJTIDENTIFIER:
                System.out.println("[ID: "+node.image+"] ");
                break;
            
            case JMMParserTreeConstants.JJTTYPE:
                System.out.println("[Type: "+node.image+"] ");
                break;
            
            case JMMParserTreeConstants.JJTINTCONST:
                System.out.println("[Int Constant: "+node.int_val+"] ");
                break;
            
            case JMMParserTreeConstants.JJTBOOLCONST:
                System.out.println("[Boolean Constant: "+node.bool_val+"] ");
                break;
            
            default:
                System.out.println(JMMParserTreeConstants.jjtNodeName[node.id]);
        }

        n_children = node.jjtGetNumChildren();
        
        for(int i = 0; i < n_children; i++){
            lhs = (SimpleNode) node.jjtGetChild(i);
            eval(lhs, depth+1);
        }
        
        return 0;
    }
}
PARSER_END(JMMParser)
SKIP :
{
//Eventually when we handle string parsing, remove these from here
" "
|"\r"
|"\t"
|"\n"
//Ignore comments

|< "/*" (~["*"])* "*" ( ~["*","/"] (~["*"])* "*" | "*" )* "/" >
|< "//" (~["\n"])+ ("\n" | "\r" | "\r\n") >

}
/*
GENERAL RULE, TOKENS THAT INCLUDE EACHOTHER (in is included by int) MUST ALWAYS APPEAR
SHORTEST TOKEN FIRST
i.e.
>in
>int
and NOT
>int
>i

TODO
Accept hex/bin number notation

The used operator precedence logic:

D -> D && C | C
C -> C < E | E
E -> E ( + | - ) T | T
T -> T ( * | / ) F | F
F -> Terminal

Removing left-recursion

D -> C D1
D1 -> && C D1 | e

C -> E C1
C1 -> < E C1 | e

E -> T E1
E1 -> ( + | - ) T E1 | e

T -> F T1
T1 -> ( * | / ) F T1 | e

F -> Terminal

*/
TOKEN:
{

< INTEGER: (["0"-"9"])+ >
|< LF: "\n" | "\r" | "\r\n" >

|< SC: ";" >
|< NEW: "new" >
|< OP: "(" >
|< CP: ")" >
|< OSB: "[" >
|< CSB: "]" >
|< OB: "{" >
|< CB: "}" >

|< NOT: "!" >
|< ADD: "+" >
|< SUB: "-" >
|< MUL: "*" >
|< DIV: "/" >
|< LESSTHAN: "<" >
|< AND: "&&" >
|< EQ: "=" >
|< SELECTOR: "." >
|< SEPARATOR: "," >

|< THIS: "this" >
|< IF: "if" >
|< ELSE: "else" >
|< WHILE: "while" >
|< RETURN: "return" >

|< BOOL: "true" | "false" >
|< BOOLEAN: "boolean" >
|< INT: "int" >

|< STRING: "String" >
|< LENGTH: "length" >
|< IMPORT: "import" >
|< EXTENDS: "extends" >
|< PUBLIC: "public" >
|< VOID: "void" >
|< MAIN: "main" >
|< STATIC: "static" >
|< CLASS: "class" >
|
// ID MUST ALWAYS BE THE LAST TOKEN BECAUSE OTHERWISE IT WILL BE MATCH EVERY STRING
< ID: ["a"-"z","A"-"Z","_","$"] ( ["a"-"z","A"-"Z","$","_","0"-"9"] )* >
}

SimpleNode Program()       : {/*@bgen(jjtree) START */
  SimpleNode jjtn000 = new SimpleNode(JJTSTART);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) START */
    try {
/*@egen*/
    (
        ( ImportDeclaration() )* ClassDeclaration() <EOF>
    )/*@bgen(jjtree)*/
      {
        jjtree.closeNodeScope(jjtn000, true);
        jjtc000 = false;
        jjtn000.jjtSetLastToken(getToken(0));
      }
/*@egen*/ {return jjtn000;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void ImportDeclaration(): {/*@bgen(jjtree) ImportDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTIMPORTDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) ImportDeclaration */
    try {
/*@egen*/
    //The method node is necessary to know if it's a method or no (since there can be a method with 0 arguments and no return (void))
    <IMPORT> (/*@bgen(jjtree) #STATIC( 0) */
               {
                 SimpleNode jjtn001 = new SimpleNode(JJTSTATIC);
                 boolean jjtc001 = true;
                 jjtree.openNodeScope(jjtn001);
                 jjtn001.jjtSetFirstToken(getToken(1));
               }
               try {
/*@egen*/ <STATIC>/*@bgen(jjtree)*/
               } finally {
                 if (jjtc001) {
                   jjtree.closeNodeScope(jjtn001,  0);
                   jjtn001.jjtSetLastToken(getToken(0));
                 }
               }
/*@egen*/            )? Identifier() ( <SELECTOR> Identifier() )
    //The grammar should only accept methods, but this is here just to check if there is any non method import
    //The exception is throwned in the semantic
    (/*@bgen(jjtree) #IMPORTMETHOD( 0) */
      {
        SimpleNode jjtn002 = new SimpleNode(JJTIMPORTMETHOD);
        boolean jjtc002 = true;
        jjtree.openNodeScope(jjtn002);
        jjtn002.jjtSetFirstToken(getToken(1));
      }
      try {
/*@egen*/ <OP>/*@bgen(jjtree)*/
      } finally {
        if (jjtc002) {
          jjtree.closeNodeScope(jjtn002,  0);
          jjtn002.jjtSetLastToken(getToken(0));
        }
      }
/*@egen*/                  ( (Type() ( <SEPARATOR> Type() )*) | <VOID> )? <CP> )?
    ( <VOID> |/*@bgen(jjtree) RETURN */
               {
                 SimpleNode jjtn003 = new SimpleNode(JJTRETURN);
                 boolean jjtc003 = true;
                 jjtree.openNodeScope(jjtn003);
                 jjtn003.jjtSetFirstToken(getToken(1));
               }
               try {
/*@egen*/ Type()/*@bgen(jjtree)*/
               } catch (Throwable jjte003) {
                 if (jjtc003) {
                   jjtree.clearNodeScope(jjtn003);
                   jjtc003 = false;
                 } else {
                   jjtree.popNode();
                 }
                 if (jjte003 instanceof RuntimeException) {
                   throw (RuntimeException)jjte003;
                 }
                 if (jjte003 instanceof ParseException) {
                   throw (ParseException)jjte003;
                 }
                 throw (Error)jjte003;
               } finally {
                 if (jjtc003) {
                   jjtree.closeNodeScope(jjtn003, true);
                   jjtn003.jjtSetLastToken(getToken(0));
                 }
               }
/*@egen*/          )? <SC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void VarDeclaration(): {/*@bgen(jjtree) VarDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTVARDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) VarDeclaration */
    try {
/*@egen*/
    Type() Identifier() <SC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void ClassHead(): {/*@bgen(jjtree) ClassHead */
  SimpleNode jjtn000 = new SimpleNode(JJTCLASSHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) ClassHead */
    try {
/*@egen*/
    Identifier() ( <EXTENDS> Identifier() )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void ClassDeclaration(): {/*@bgen(jjtree) ClassDeclaration */
  SimpleNode jjtn000 = new SimpleNode(JJTCLASSDECLARATION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) ClassDeclaration */
    try {
/*@egen*/
    <CLASS> ClassHead() <OB>
        ( VarDeclaration() )*
        ( MethodDeclaration() )*
        
    <CB>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void MethodHead(): {/*@bgen(jjtree) MethodHead */
  SimpleNode jjtn000 = new SimpleNode(JJTMETHODHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) MethodHead */
    try {
/*@egen*/
    //Return is unnecessary here because the first token MUST be a Type, and is always the return type
    //First token is return type, Second token is method name
    //From then on, Type Identifier pairs are the arguments 
    Type() /* #RETURN */ Identifier() <OP> ( (Type() Identifier() ( <SEPARATOR> Type() Identifier() )* ) | <VOID> )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void MainMethod(): {/*@bgen(jjtree) MainMethod */
  SimpleNode jjtn000 = new SimpleNode(JJTMAINMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) MainMethod */
    try {
/*@egen*/
    <STATIC> <VOID> <MAIN> <OP>
        <STRING> <OSB> <CSB> Identifier()
    <CP> <OB>
    ( LOOKAHEAD(2) VarDeclaration() )*
    ( Statement() )*
    <CB>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void NormalMethod(): {/*@bgen(jjtree) NormalMethod */
  SimpleNode jjtn000 = new SimpleNode(JJTNORMALMETHOD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) NormalMethod */
    try {
/*@egen*/
    MethodHead()
    <CP> <OB>
        ( LOOKAHEAD(2) VarDeclaration() )*
        ( Statement() )*
        ( <RETURN>/*@bgen(jjtree) RETURN */
                   {
                     SimpleNode jjtn001 = new SimpleNode(JJTRETURN);
                     boolean jjtc001 = true;
                     jjtree.openNodeScope(jjtn001);
                     jjtn001.jjtSetFirstToken(getToken(1));
                   }
                   try {
/*@egen*/ Expression()/*@bgen(jjtree)*/
                   } catch (Throwable jjte001) {
                     if (jjtc001) {
                       jjtree.clearNodeScope(jjtn001);
                       jjtc001 = false;
                     } else {
                       jjtree.popNode();
                     }
                     if (jjte001 instanceof RuntimeException) {
                       throw (RuntimeException)jjte001;
                     }
                     if (jjte001 instanceof ParseException) {
                       throw (ParseException)jjte001;
                     }
                     throw (Error)jjte001;
                   } finally {
                     if (jjtc001) {
                       jjtree.closeNodeScope(jjtn001, true);
                       jjtn001.jjtSetLastToken(getToken(0));
                     }
                   }
/*@egen*/         <SC> )?
    <CB>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void MethodDeclaration()     : {}
{
    <PUBLIC>
        (
        NormalMethod()
        |
        MainMethod()
        )
}

void BoolConst(): {/*@bgen(jjtree) BoolConst */
                   SimpleNode jjtn000 = new SimpleNode(JJTBOOLCONST);
                   boolean jjtc000 = true;
                   jjtree.openNodeScope(jjtn000);
                   jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/Token t;}
{/*@bgen(jjtree) BoolConst */
    try {
/*@egen*/
    t=<BOOL>/*@bgen(jjtree)*/
            {
              jjtree.closeNodeScope(jjtn000, true);
              jjtc000 = false;
              jjtn000.jjtSetLastToken(getToken(0));
            }
/*@egen*/{
        jjtn000.bool_val = Boolean.parseBoolean(t.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}
void IntConst(): {/*@bgen(jjtree) IntConst */
                  SimpleNode jjtn000 = new SimpleNode(JJTINTCONST);
                  boolean jjtc000 = true;
                  jjtree.openNodeScope(jjtn000);
                  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/Token t;}
{/*@bgen(jjtree) IntConst */
    try {
/*@egen*/
    t=<INTEGER>/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtn000.jjtSetLastToken(getToken(0));
               }
/*@egen*/{
        jjtn000.int_val = Integer.parseInt(t.image);
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void And()     :{}
{
    Lessthan() And1()
}

void And1()     : {}
{
    "&&"/*@bgen(jjtree) #AND( 2) */
         {
           SimpleNode jjtn001 = new SimpleNode(JJTAND);
           boolean jjtc001 = true;
           jjtree.openNodeScope(jjtn001);
           jjtn001.jjtSetFirstToken(getToken(1));
         }
         try {
/*@egen*/ Lessthan()/*@bgen(jjtree)*/
         } catch (Throwable jjte001) {
           if (jjtc001) {
             jjtree.clearNodeScope(jjtn001);
             jjtc001 = false;
           } else {
             jjtree.popNode();
           }
           if (jjte001 instanceof RuntimeException) {
             throw (RuntimeException)jjte001;
           }
           if (jjte001 instanceof ParseException) {
             throw (ParseException)jjte001;
           }
           throw (Error)jjte001;
         } finally {
           if (jjtc001) {
             jjtree.closeNodeScope(jjtn001,  2);
             jjtn001.jjtSetLastToken(getToken(0));
           }
         }
/*@egen*/         And1()
    |
    Empty()
}

void Lessthan()     : {}
{
    Add() Lessthan1()
}

void Lessthan1()     : {}
{
    "<"/*@bgen(jjtree) #LESSTHAN( 2) */
        {
          SimpleNode jjtn001 = new SimpleNode(JJTLESSTHAN);
          boolean jjtc001 = true;
          jjtree.openNodeScope(jjtn001);
          jjtn001.jjtSetFirstToken(getToken(1));
        }
        try {
/*@egen*/ Add()/*@bgen(jjtree)*/
        } catch (Throwable jjte001) {
          if (jjtc001) {
            jjtree.clearNodeScope(jjtn001);
            jjtc001 = false;
          } else {
            jjtree.popNode();
          }
          if (jjte001 instanceof RuntimeException) {
            throw (RuntimeException)jjte001;
          }
          if (jjte001 instanceof ParseException) {
            throw (ParseException)jjte001;
          }
          throw (Error)jjte001;
        } finally {
          if (jjtc001) {
            jjtree.closeNodeScope(jjtn001,  2);
            jjtn001.jjtSetLastToken(getToken(0));
          }
        }
/*@egen*/              Lessthan1()
    |
    Empty()
}

void Add()     : {}
{
    Mul() Add1()
}

void Add1()     : {}
{
    (
        "+"/*@bgen(jjtree) #ADD( 2) */
            {
              SimpleNode jjtn001 = new SimpleNode(JJTADD);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
              jjtn001.jjtSetFirstToken(getToken(1));
            }
            try {
/*@egen*/ Mul()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  2);
                jjtn001.jjtSetLastToken(getToken(0));
              }
            }
/*@egen*/        
        |
        "-"/*@bgen(jjtree) #SUB( 2) */
            {
              SimpleNode jjtn002 = new SimpleNode(JJTSUB);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
              jjtn002.jjtSetFirstToken(getToken(1));
            }
            try {
/*@egen*/ Mul()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  2);
                jjtn002.jjtSetLastToken(getToken(0));
              }
            }
/*@egen*/         )
     Add1()
    |
    Empty()
}

void Mul()     : {}
{
    Node() Mul1()
}

void Mul1()     : {}
{
    (
        "*"/*@bgen(jjtree) #MUL( 2) */
            {
              SimpleNode jjtn001 = new SimpleNode(JJTMUL);
              boolean jjtc001 = true;
              jjtree.openNodeScope(jjtn001);
              jjtn001.jjtSetFirstToken(getToken(1));
            }
            try {
/*@egen*/ Node()/*@bgen(jjtree)*/
            } catch (Throwable jjte001) {
              if (jjtc001) {
                jjtree.clearNodeScope(jjtn001);
                jjtc001 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte001 instanceof RuntimeException) {
                throw (RuntimeException)jjte001;
              }
              if (jjte001 instanceof ParseException) {
                throw (ParseException)jjte001;
              }
              throw (Error)jjte001;
            } finally {
              if (jjtc001) {
                jjtree.closeNodeScope(jjtn001,  2);
                jjtn001.jjtSetLastToken(getToken(0));
              }
            }
/*@egen*/        
        |
        "/"/*@bgen(jjtree) #DIV( 2) */
            {
              SimpleNode jjtn002 = new SimpleNode(JJTDIV);
              boolean jjtc002 = true;
              jjtree.openNodeScope(jjtn002);
              jjtn002.jjtSetFirstToken(getToken(1));
            }
            try {
/*@egen*/ Node()/*@bgen(jjtree)*/
            } catch (Throwable jjte002) {
              if (jjtc002) {
                jjtree.clearNodeScope(jjtn002);
                jjtc002 = false;
              } else {
                jjtree.popNode();
              }
              if (jjte002 instanceof RuntimeException) {
                throw (RuntimeException)jjte002;
              }
              if (jjte002 instanceof ParseException) {
                throw (ParseException)jjte002;
              }
              throw (Error)jjte002;
            } finally {
              if (jjtc002) {
                jjtree.closeNodeScope(jjtn002,  2);
                jjtn002.jjtSetLastToken(getToken(0));
              }
            }
/*@egen*/        
    ) Mul1()
    |
    Empty()
}

void SelectorArguments(): {/*@bgen(jjtree) SelectorArguments */
  SimpleNode jjtn000 = new SimpleNode(JJTSELECTORARGUMENTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) SelectorArguments */
    try {
/*@egen*/
    <OP> ( Expression() ( <SEPARATOR> Expression() )* )? <CP>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Selector_1()         : {/*@bgen(jjtree) SELECTOR */
  SimpleNode jjtn000 = new SimpleNode(JJTSELECTOR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) SELECTOR */
    try {
/*@egen*/
    Identifier() ( SelectorArguments() )?
    |/*@bgen(jjtree) LENGTH */
    {
      SimpleNode jjtn001 = new SimpleNode(JJTLENGTH);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtn001.jjtSetFirstToken(getToken(1));
    }
    try {
/*@egen*/
    <LENGTH>/*@bgen(jjtree)*/
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
        jjtn001.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/        /*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Selector()     : {}
{
    <SELECTOR> Selector_1()
    |
    ArrayAccess()
    //<OSB> #ArrayAccess Expression() <CSB>
}

void IdentifierAccess():{/*@bgen(jjtree) IdentifierAccess */
  SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIERACCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) IdentifierAccess */
    try {
/*@egen*/
    Identifier() ( Selector() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void This()     : {/*@bgen(jjtree) THIS */
  SimpleNode jjtn000 = new SimpleNode(JJTTHIS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) THIS */
    try {
/*@egen*/
    <THIS> ( Selector() )*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void New(): {/*@bgen(jjtree) New */
  SimpleNode jjtn000 = new SimpleNode(JJTNEW);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) New */
    try {
/*@egen*/
    <INT> <OSB> Expression() <CSB>
    |
    Identifier() <OP> <CP>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Negate(): {/*@bgen(jjtree) Negate */
  SimpleNode jjtn000 = new SimpleNode(JJTNEGATE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Negate */
    try {
/*@egen*/
    <NOT> Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Node()     : {}
{
    IntConst()
    |
    BoolConst()
    |
    IdentifierAccess()
    |
    <OP> And() <CP>
    |
    This()
    |
    <NEW> New() ( Selector() )*
    |
    Negate()

}

void Expression()     : {}
{
    And()
}


//Access here is unnecessary because the First Token is always the target ID
//More tokens imply an expression that can then be computed
void ArrayAccess():{/*@bgen(jjtree) ArrayAccess */
  SimpleNode jjtn000 = new SimpleNode(JJTARRAYACCESS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/} //#void /* #Access */: {}
{/*@bgen(jjtree) ArrayAccess */
    try {
/*@egen*/
    <OSB> Expression() <CSB>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Target()       : {/*@bgen(jjtree) Target */
  SimpleNode jjtn000 = new SimpleNode(JJTTARGET);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Target */
    try {
/*@egen*/
    Identifier() ( ArrayAccess() )?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}
void Attribution()            : {/*@bgen(jjtree) Attribution */
  SimpleNode jjtn000 = new SimpleNode(JJTATTRIBUTION);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) Attribution */
    try {
/*@egen*/
    Target() <EQ> Expression() <SC>/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Statement()     : {}
{
    IfStructure()
    |
    WhileStructure()
    |
    <OB> ( Statement() )* <CB>
    |
    LOOKAHEAD(2)
    Attribution()
    |/*@bgen(jjtree) DIRECTEXPRESSION */
    {
      SimpleNode jjtn001 = new SimpleNode(JJTDIRECTEXPRESSION);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
      jjtn001.jjtSetFirstToken(getToken(1));
    }
    try {
/*@egen*/
    Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, true);
        jjtn001.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/                   <SC>
}

void IfHead(): {/*@bgen(jjtree) IfHead */
  SimpleNode jjtn000 = new SimpleNode(JJTIFHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) IfHead */
    try {
/*@egen*/
    Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void IfStructure(): {/*@bgen(jjtree) IfStructure */
  SimpleNode jjtn000 = new SimpleNode(JJTIFSTRUCTURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) IfStructure */
    try {
/*@egen*/
    <IF> <OP> IfHead()  <CP> Statement() ElseStructure()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void ElseStructure(): {/*@bgen(jjtree) ElseStructure */
  SimpleNode jjtn000 = new SimpleNode(JJTELSESTRUCTURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) ElseStructure */
    try {
/*@egen*/
    <ELSE> Statement()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

//Needed because expressions inside the while body would be confused with those inside the head
void WhileHead(): {/*@bgen(jjtree) WhileHead */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILEHEAD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) WhileHead */
    try {
/*@egen*/
    Expression()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void WhileStructure(): {/*@bgen(jjtree) WhileStructure */
  SimpleNode jjtn000 = new SimpleNode(JJTWHILESTRUCTURE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
  jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/}
{/*@bgen(jjtree) WhileStructure */
    try {
/*@egen*/
    <WHILE>
    try{
        <OP> WhileHead() <CP> Statement()
    }catch (ParseException e) {
        System.out.println("COULD NOT PARSE WHILE");
        error_skipto(CB, e);
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Type(): {/*@bgen(jjtree) Type */
              SimpleNode jjtn000 = new SimpleNode(JJTTYPE);
              boolean jjtc000 = true;
              jjtree.openNodeScope(jjtn000);
              jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/Token t;}
{/*@bgen(jjtree) Type */
    try {
/*@egen*/
    <INT> (
        <OSB> <CSB>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtn000.jjtSetLastToken(getToken(0));
                   }
/*@egen*/{
            jjtn000.image = "int[]";
        }
        |
        Empty()/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtn000.jjtSetLastToken(getToken(0));
               }
/*@egen*/{
            jjtn000.image = "int";
        }
        )
    |
    <STRING> (
        <OSB> <CSB>/*@bgen(jjtree)*/
                   {
                     jjtree.closeNodeScope(jjtn000, true);
                     jjtc000 = false;
                     jjtn000.jjtSetLastToken(getToken(0));
                   }
/*@egen*/{
            jjtn000.image = "String[]";
        }
        |
        Empty()/*@bgen(jjtree)*/
               {
                 jjtree.closeNodeScope(jjtn000, true);
                 jjtc000 = false;
                 jjtn000.jjtSetLastToken(getToken(0));
               }
/*@egen*/{
            jjtn000.image = "String";
        }
        )
    |
    <BOOLEAN>/*@bgen(jjtree)*/
             {
               jjtree.closeNodeScope(jjtn000, true);
               jjtc000 = false;
               jjtn000.jjtSetLastToken(getToken(0));
             }
/*@egen*/{
        jjtn000.image = "boolean";
    }
    |
    t=<ID>/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtn000.jjtSetLastToken(getToken(0));
          }
/*@egen*/{
        jjtn000.image = t.image+"";
    }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

void Empty()     : {}
{
    {}
}

void Identifier(): {/*@bgen(jjtree) Identifier */
                    SimpleNode jjtn000 = new SimpleNode(JJTIDENTIFIER);
                    boolean jjtc000 = true;
                    jjtree.openNodeScope(jjtn000);
                    jjtn000.jjtSetFirstToken(getToken(1));
/*@egen*/Token t;}
{/*@bgen(jjtree) Identifier */
    try {
/*@egen*/
    t=<ID>/*@bgen(jjtree)*/
          {
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            jjtn000.jjtSetLastToken(getToken(0));
          }
/*@egen*/{
        jjtn000.image = t.image+"";
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
        jjtn000.jjtSetLastToken(getToken(0));
      }
    }
/*@egen*/
}

JAVACODE
//Addapted from https://javacc.github.io/javacc/tutorials/error-handling.html
void error_skipto(int kind, ParseException e) throws Exception{/*@bgen(jjtree) error_skipto */
 SimpleNode jjtn000 = new SimpleNode(JJTERROR_SKIPTO);
 boolean jjtc000 = true;
 jjtree.openNodeScope(jjtn000);
 jjtn000.jjtSetFirstToken(getToken(1));
 try {
/*@egen*/
    if(all_exceptions.size() == MAX_EXCEPTIONS){
        throw new Exception("Maximum ammount of exceptions caught.");
    }
    all_exceptions.add(e);
    Token t;
    do{
        t = getNextToken();
    }while(t.kind != kind);/*@bgen(jjtree)*/
 } catch (Throwable jjte000) {
   if (jjtc000) {
     jjtree.clearNodeScope(jjtn000);
     jjtc000 = false;
   } else {
     jjtree.popNode();
   }
   if (jjte000 instanceof Exception) {
     throw (Exception)jjte000;
   }
   throw (Error)jjte000;
 } finally {
   if (jjtc000) {
     jjtree.closeNodeScope(jjtn000, true);
     jjtn000.jjtSetLastToken(getToken(0));
   }
 }
/*@egen*/
}